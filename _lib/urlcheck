<?php 
/**
 *
 * URL CHECK SCRIPT
 * Simple script to locate urls within any text file--using a set of regular 
 * expressions--and determine their validity based on the header response code 
 * returned for each url
 *
 * @version 0.1.2
 * @author  Rob Frawley <rfrawley@scribenet.com>
 * @license MIT License
 *
 */

/**
 *
 * User configuration variables
 *
 */

/* file extension to search for */
$ext = 'scml';

/* pattern to find URLs */
$patterns = array(
	'{<url id="(.*?)">.*?</url>}i',
	'{<url>(.*?)</url>}i'
);

/* array of response codes that should throw an error */
$invalidResponse = array( 
	400, 401, 403, 404, 405, 406, 407, 408, 409, 410, 
	500, 501, 502, 503, 504, 505, 507, 508, 509, 510
);

/**
 *
 * Internal configuration variables
 *
 */

/* directory deparator (platform independent) and root directory */
$ds   = DIRECTORY_SEPARATOR;
$root = '.' . $ds;

/*
 *
 * Inclusion of any external dependencies
 *
 */

require '/scripts/_lib/consoleIO';

/*
 *
 * sub-routine declarations
 *
 */

function getResponseCode( $url )
{

	/* get response code from header, use @ to supress *all* warnings */
	$headers = @get_headers( $url, 1 );
	return @substr( @$headers[0], 9, 3 );

}

function requireProtocol( $url )
{

	/* the url must begin with a protocol for get_headers to succeed */
	if( substr($url, 0, 7) !== 'http://' && 
		substr($url, 0, 8) !== 'https://' ) 
	{
		$url = 'http://'.$url;
	}

	return $url;

}

function performUrlsCheck( 
	$urls, 
	$invalidResponse = array( 404 ), 
	$headerText = 'Checking URL response code:' )
{

	/* inform user, we're 'bout to check them URL response codes! */
	IO::os( $headerText );

	/* initialize badUrl array */
	$badUrls = array();

	/* this level of the loop is the URLs themselves */
	foreach( $urls as $i => $url )
	{

		/* a protocol is required... */
		$url = requireProtocol( $url );

		/* tell the user what's happening... */
		IO::status_info( 'Checking URL: ' . str_replace('%', '%%', $url) );

		/* get the response code */
		$responseCode = getResponseCode( $url );

		/* if the response code is blacklisted, url failed */
		if( in_array($responseCode, $invalidResponse) )
		{
			IO::status_result_bad( 'Er ['.$responseCode.']' );
			$badUrls[] = $url;	
		}
		/* if no response code was provided, url failed */
		elseif( empty($responseCode) )
		{
			IO::status_result_bad( 'Er [UNKNOWN]' );

			/* www are added sometimes when they should not... */
			$urlAlt = str_replace( '://www.', '://', $url );

			/* tell the user what's happening... */
			IO::status_info( 'Re-checking URL (w/o www): ' . str_replace('%', '%%', $urlAlt) );

			/* get response code */
			$responseCode = getResponseCode( $urlAlt );

			/* if the response code is blacklisted, url failed */
			if( in_array($responseCode, $invalidResponse) )
			{
				IO::status_result_bad( 'Er ['.$responseCode.']' );
				$badUrls[] = $url;	
			}
			/* otherwise, yay! */
			else
			{
				IO::status_result_good( 'Ok ['.$responseCode.']' );
				IO::warn( 'The URL '.$url.' should read '.$urlAlt );
			}

		}
		/* otherwise, yay! */
		else
		{
			IO::status_result_good( 'Ok ['.$responseCode.']' );
		}

	}

	/* return the failed urls */
	return $badUrls;

}

function readDirectoryAndMatch( $root, $ext, $patterns )
{

	/* inform user that we're scanning the directory */
	IO::os( 'Scanning directory '.$root.' for extention '.$ext );

	/* clear file stat cache */
	clearstatcache();

	/* initialize matches var */
	$allMatches = array();

	/* scan directory for files */
	$dirFiles   = scandir( $root );

	/* loop through the found files */
	foreach( $dirFiles as $i => $f )
	{

		/* ignore current and parent directory, as well as this script itself */
		if( $f == '.' || $f == '..' || $f == basename(__FILE__) ) continue;

		/* ignore anything not matching the defined extention */
		if( pathinfo( $f, PATHINFO_EXTENSION ) !== $ext ) continue;

		/* inform user when valid file found */
		IO::o( 'Reading '.$f );

		/* file contents and file name arrays */
		$file = file_get_contents( $root.$f );

		/* loop through defined search patterns */
		for( $j = 0; $j < count($patterns); $j++ )
		{
			/* reset matches to empty array */
			$matches = array();

			/* do the search on file contents */
			preg_match_all( $patterns[$j], $file, $matches );

			/* the matches we want are located at index 1 */
			$matches = isset( $matches[1]) && is_array($matches[1] ) ? 
				$matches[1] :
				array()
			;

			/* loop through matches */
			foreach( $matches as $k => $m )
			{
				/* only add each url to the matches list once */
				if(! in_array( $m, $allMatches ) )
				{
					$allMatches[] = $m;
				}

			}
		}
	}


	/* return the matches */
	return $allMatches;

}

/*
 *
 * Go...
 *
 */

/* welcome message */
IO::sT( 'URL Validation Operation' );
IO::sT( 'by Rob Frawley of Scribe Inc.' );

/* read directory */
$allMatches = readDirectoryAndMatch( $root, $ext, $patterns );

/* perform first-round check */
$badUrls = performUrlsCheck( 
	$allMatches, 
	$invalidResponse 
);

/* perform second-round check on previous failures */
$badUrls = performUrlsCheck( 
	$badUrls, 
	$invalidResponse, 
	'Re-Checking failed URLs' 
);

/* totals counts... */
IO::status_info( 'The number of bad URLs found within your ScML files...' );

/* if zero, all green */
if( count($badUrls) === 0 )
{
	IO::status_result_good( 0 );
}
/* if not zero, bad */
else
{
	IO::status_result_bad( count($badUrls) );
}

/* goodbye message, exit with 0 status code for "all ok" */
IO::done( 'All done; goodbye...' );
exit( 0 );
?>